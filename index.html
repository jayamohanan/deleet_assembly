<!-- version: v1.0.0 (2025-08-21, IST) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kerala Administrative Boundaries ‚Äì Interactive Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <style>
    :root {
      --sidebar-width: 340px; /* shrinks on small screens */
      --gap: 10px;
      --panel-pad: 12px;
      --radius: 14px;
      --shadow: 0 6px 24px rgba(0,0,0,0.12);
    }
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    #app { display: grid; grid-template-columns: 1fr var(--sidebar-width); height: 100%; }
    #map { width: 100%; height: 100%; background: #fff; }

    /* Sidebar */
    .sidebar {
      position: relative;
      background: #fafafa;
      border-left: 1px solid #e5e5e5;
      padding: 16px 12px 24px 12px;
      overflow-y: auto;
    }
    .sidebar-inner { padding-top: 12px; }
    .panel {
      background: #ffffff;
      border: 1px solid #e6e6e6;
      border-radius: var(--radius);
      padding: var(--panel-pad);
      margin-bottom: 14px;
      box-shadow: var(--shadow);
    }
    .panel h3 { margin: 0 0 10px 0; font-size: 16px; }
    .row { display: flex; gap: var(--gap); align-items: center; margin: 8px 0; flex-wrap: wrap; }
    label { font-size: 12px; color: #333; }
    select, input[type="text"], input[type="range"], input[type="color"] {
      width: 100%;
      box-sizing: border-box;
      padding: 8px;
      border: 1px solid #d0d0d0;
      border-radius: 10px;
      background: #fff;
    }
    .muted { font-size: 12px; color: #666; }
    .btns { display: flex; gap: 10px; margin-top: 8px; }
    button { flex: 1; padding: 10px 12px; border-radius: 12px; border: 1px solid #d9d9d9; background: #fff; cursor: pointer; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:hover { filter: brightness(0.98); }

    /* Version badge */
    .version-badge {
      position: fixed; top: 12px; right: 12px; z-index: 9999;
      background: rgba(17,17,17,0.9); color: #fff; padding: 6px 10px; border-radius: 999px; font-size: 12px;
      box-shadow: var(--shadow);
      pointer-events: none; /* always overlay everything */
    }

    /* Sidebar toggle for small screens */
    .toggle {
      position: fixed; left: 10px; top: 10px; z-index: 10000;
      border-radius: 999px; border: 1px solid #ccc; background: #fff; padding: 8px 10px; cursor: pointer; box-shadow: var(--shadow);
    }

    @media (max-width: 1100px) {
      :root { --sidebar-width: 300px; }
    }
    @media (max-width: 900px) {
      #app { grid-template-columns: 1fr; }
      .sidebar { position: fixed; right: 10px; top: 54px; bottom: 10px; width: calc(100% - 20px); max-width: 480px; border-radius: var(--radius); display: none; }
      .sidebar.open { display: block; }
      .toggle { display: block; }
    }

    /* Leaflet control spacing so it doesn't clash with our version badge */
    .leaflet-top.leaflet-right { margin-top: 40px; }
  </style>
</head>
<body>
  <div class="version-badge" id="versionBadge">v1.0.0</div>
  <button class="toggle" id="toggleBtn" aria-label="Toggle controls" title="Show/Hide Controls">Panels</button>
  <div id="app">
    <div id="map" role="region" aria-label="Kerala boundary map"></div>

    <!-- Right-aligned, vertically stacked input panels -->
    <aside class="sidebar" id="sidebar" aria-label="Boundary selection panels">
      <div class="sidebar-inner">
        <div class="panel" id="basemapPanel">
          <h3>üó∫Ô∏è Base Map</h3>
          <div class="row">
            <label for="basemapSelect">Choose base map (select "None" to hide)</label>
            <select id="basemapSelect"></select>
          </div>
        </div>

        <div class="panel" id="districtPanel">
          <h3>üìç Districts</h3>
          <div class="row">
            <label for="districtSearch">Search by Name (matches the <code>Name</code> field)</label>
            <input id="districtSearch" type="text" placeholder="Type to filter list‚Ä¶" autocomplete="off" />
          </div>
          <div class="row">
            <label for="districtSelect">Select one or more districts</label>
            <select id="districtSelect" multiple size="8" aria-multiselectable="true"></select>
          </div>
          <div class="row">
            <div style="flex:1">
              <label for="districtColor">Color</label>
              <input id="districtColor" type="color" value="#000000" />
            </div>
            <div style="flex:2">
              <label for="districtTrans">Fill transparency (higher = more see‚Äëthrough)</label>
              <input id="districtTrans" type="range" min="0" max="100" value="100" />
              <div class="muted" id="districtTransVal">100%</div>
            </div>
          </div>
          <div class="btns">
            <button id="drawDistrict" class="primary">Draw</button>
            <button id="clearDistrict">Clear</button>
          </div>
        </div>

        <div class="panel" id="assemblyPanel">
          <h3>üß≠ Assemblies</h3>
          <div class="row">
            <label for="assemblySearch">Search by Name (matches the <code>Name</code> field)</label>
            <input id="assemblySearch" type="text" placeholder="Type to filter list‚Ä¶" autocomplete="off" />
          </div>
          <div class="row">
            <label for="assemblySelect">Select one or more assemblies</label>
            <select id="assemblySelect" multiple size="10" aria-multiselectable="true"></select>
          </div>
          <div class="row">
            <div style="flex:1">
              <label for="assemblyColor">Color</label>
              <input id="assemblyColor" type="color" value="#000000" />
            </div>
            <div style="flex:2">
              <label for="assemblyTrans">Fill transparency (higher = more see‚Äëthrough)</label>
              <input id="assemblyTrans" type="range" min="0" max="100" value="100" />
              <div class="muted" id="assemblyTransVal">100%</div>
            </div>
          </div>
          <div class="btns">
            <button id="drawAssembly" class="primary">Draw</button>
            <button id="clearAssembly">Clear</button>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    // === Version badge (must always overlay everything) ===
    const VERSION = 'v1.0.0';
    document.getElementById('versionBadge').textContent = VERSION;

    // === Map init ===
    const map = L.map('map', { center: [10.1632, 76.6413], zoom: 8, zoomControl: true });

    // Create custom panes for strict draw order (higher zIndex overlays lower):
    map.createPane('state');      map.getPane('state').style.zIndex = 300;
    map.createPane('districts');  map.getPane('districts').style.zIndex = 350;
    map.createPane('assemblies'); map.getPane('assemblies').style.zIndex = 400;
    map.createPane('locals');     map.getPane('locals').style.zIndex = 450; // reserved for future local bodies

    // === Base maps (including a None option) ===
    const baseLayers = {
      'None (hide base map)': L.layerGroup(),
      'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap' }),
      'Carto Light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 20, attribution: '&copy; CARTO &copy; OpenStreetMap' }),
      'Esri World Imagery': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 20, attribution: 'Tiles &copy; Esri' })
    };

    // Default to OSM
    let activeBase = baseLayers['OpenStreetMap'];
    activeBase.addTo(map);

    // Populate basemap select
    const basemapSelect = document.getElementById('basemapSelect');
    Object.keys(baseLayers).forEach((name) => {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name;
      if (name === 'OpenStreetMap') opt.selected = true;
      basemapSelect.appendChild(opt);
    });
    basemapSelect.addEventListener('change', () => {
      if (activeBase) map.removeLayer(activeBase);
      activeBase = baseLayers[basemapSelect.value];
      if (activeBase) activeBase.addTo(map);
    });

    // === Data layer groups (kept separate so Clear works per type) ===
    const districtLayerGroup = L.layerGroup().addTo(map);
    const assemblyLayerGroup = L.layerGroup().addTo(map);

    // === Utility: fetch and parse geojson ===
    async function loadGeoJSON(path) {
      const resp = await fetch(path);
      if (!resp.ok) throw new Error('Failed to load ' + path);
      return await resp.json();
    }

    // === Populate selects with unique sorted names (skip null/empty) ===
    function fillNameOptions(selectEl, features) {
      const names = new Set();
      for (const f of features) {
        const raw = (f.properties && f.properties.Name != null) ? String(f.properties.Name) : '';
        const val = raw.trim();
        if (val) names.add(val);
      }
      const sorted = Array.from(names).sort((a,b)=>a.localeCompare(b,'en',{sensitivity:'base'}));
      selectEl.innerHTML = '';
      for (const name of sorted) {
        const opt = document.createElement('option');
        opt.value = name; opt.textContent = name;
        selectEl.appendChild(opt);
      }
    }

    // === Filter select options via a text input ===
    function wireFilter(searchInput, selectEl) {
      searchInput.addEventListener('input', () => {
        const q = searchInput.value.trim().toLowerCase();
        for (const opt of selectEl.options) {
          const show = !q || opt.value.toLowerCase().includes(q);
          opt.hidden = !show;
        }
      });
    }

    // === Draw helpers per type (ensuring outline + fill with chosen transparency) ===
    function transparencyToOpacity(transVal) { // 0..100 transparency => 0..1 fillOpacity
      const t = Math.max(0, Math.min(100, Number(transVal)||0));
      const opacity = 1 - (t/100); // 100% transparent -> 0 opacity
      return opacity;
    }

    function drawFeaturesByNames(features, namesWanted, color, paneName, targetGroup) {
      const wanted = new Set(Array.from(namesWanted, s => String(s).trim().toLowerCase()));
      const matched = features.filter(f => {
        const nm = (f.properties && f.properties.Name != null) ? String(f.properties.Name).trim().toLowerCase() : '';
        return nm && wanted.has(nm);
      });
      return matched.map(f => L.geoJSON(f, {
        pane: paneName,
        style: (/* feature */) => ({ color, weight: 2, opacity: 1, fillColor: color, fillOpacity: currentFillOpacity[paneName] })
      }).addTo(targetGroup));
    }

    // Track current fillOpacity per pane (so Clear/Draw keeps user setting)
    const currentFillOpacity = {
      districts: transparencyToOpacity(100),
      assemblies: transparencyToOpacity(100)
    };

    // === Load both GeoJSONs, then wire UI ===
    let districtGeo = null, assemblyGeo = null;
    (async function init() {
      try {
        // Note: files must exist in the same directory/repo
        [districtGeo, assemblyGeo] = await Promise.all([
          loadGeoJSON('district_V15.geojson'),
          loadGeoJSON('assembly_V15.geojson')
        ]);

        // Populate selects
        fillNameOptions(document.getElementById('districtSelect'), districtGeo.features || []);
        fillNameOptions(document.getElementById('assemblySelect'), assemblyGeo.features || []);

        // Wire search filters
        wireFilter(document.getElementById('districtSearch'), document.getElementById('districtSelect'));
        wireFilter(document.getElementById('assemblySearch'), document.getElementById('assemblySelect'));

        // Wire transparency readouts
        const dTrans = document.getElementById('districtTrans');
        const aTrans = document.getElementById('assemblyTrans');
        const dTransVal = document.getElementById('districtTransVal');
        const aTransVal = document.getElementById('assemblyTransVal');
        dTrans.addEventListener('input', () => {
          dTransVal.textContent = dTrans.value + '%';
          currentFillOpacity.districts = transparencyToOpacity(dTrans.value);
          // update existing layers styles
          districtLayerGroup.eachLayer(layer => { if (layer.setStyle) layer.setStyle({ fillOpacity: currentFillOpacity.districts }); });
        });
        aTrans.addEventListener('input', () => {
          aTransVal.textContent = aTrans.value + '%';
          currentFillOpacity.assemblies = transparencyToOpacity(aTrans.value);
          assemblyLayerGroup.eachLayer(layer => { if (layer.setStyle) layer.setStyle({ fillOpacity: currentFillOpacity.assemblies }); });
        });

        // Wire draw/clear buttons
        document.getElementById('drawDistrict').addEventListener('click', () => {
          const select = document.getElementById('districtSelect');
          const color = document.getElementById('districtColor').value || '#000000';
          const selected = Array.from(select.selectedOptions).map(o => o.value);
          if (!selected.length) { alert('Please select at least one district.'); return; }
          // Draw high-to-low hierarchy: districts use pane 'districts'
          drawFeaturesByNames(districtGeo.features || [], selected, color, 'districts', districtLayerGroup);
        });
        document.getElementById('clearDistrict').addEventListener('click', () => {
          districtLayerGroup.clearLayers();
        });

        document.getElementById('drawAssembly').addEventListener('click', () => {
          const select = document.getElementById('assemblySelect');
          const color = document.getElementById('assemblyColor').value || '#000000';
          const selected = Array.from(select.selectedOptions).map(o => o.value);
          if (!selected.length) { alert('Please select at least one assembly.'); return; }
          // Assemblies draw on higher pane so they overlay districts
          drawFeaturesByNames(assemblyGeo.features || [], selected, color, 'assemblies', assemblyLayerGroup);
        });
        document.getElementById('clearAssembly').addEventListener('click', () => {
          assemblyLayerGroup.clearLayers();
        });

        // Fit map to Kerala bounds if available from either dataset
        const any = (districtGeo.features && districtGeo.features[0]) || (assemblyGeo.features && assemblyGeo.features[0]);
        if (any) {
          const tmp = L.geoJSON(any);
          try { map.fitBounds(tmp.getBounds(), { padding: [20,20] }); } catch {}
          tmp.remove();
        }
      } catch (err) {
        console.error(err);
        alert('Failed to load boundary data. Ensure geojson files exist next to this HTML.');
      }
    })();

    // Sidebar toggle for small screens
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.getElementById('toggleBtn');
    function setSidebar(open) { sidebar.classList.toggle('open', open); }
    toggleBtn.addEventListener('click', () => setSidebar(!sidebar.classList.contains('open')));
    // Start with sidebar open on desktop, closed on small screens
    const mq = window.matchMedia('(max-width: 900px)');
    function applyMQ(e){ setSidebar(!e.matches); }
    mq.addEventListener('change', applyMQ); applyMQ(mq);
  </script>
</body>
</html>
